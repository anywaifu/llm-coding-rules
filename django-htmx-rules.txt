# Django Project Conventions and Guidelines

Follow these conventions strictly when generating or modifying code for this Django project.

## Core Principles: Separation of Concerns

- **Views:** Handle HTTP request/response, view-level auth/permissions, presentation formatting, orchestrate service calls. Minimal logic.
- **Services:** Contain business logic, orchestrate model/interface interactions, handle domain permissions, manage transactions.
- **Models:** Represent data structure/relationships. Simple, reusable query helpers/properties *without* business logic. Persistence (`.save()`, `.delete()`) called from services.
- **Forms:** Handle user input validation based on defined rules. No DB interaction or business logic.
- **Interfaces:** Communicate with external services/APIs. No internal business logic.
- **Tasks:** Execute background jobs, typically by calling service methods.
- **Templates:** Handle presentation logic (DTL, HTMX).

---

## Services (`services/` package)

- **Purpose:** Encapsulate business logic, complex workflows, multi-model/external interactions.
- **Location:** `app/services/`. Import into `app/services/__init__.py` (e.g., `from .profile_service import ProfileService`).
- **Interaction:**
    - Operate on model instances.
    - Call model query methods (e.g., `User.get_by_id(...)`).
    - Responsible for persistence (`.save()`, `.delete()`).
    - Can directly set model attributes before saving.
- **Business Logic:** Define domain rules and workflows (e.g., update permissions based on role).
- **Domain Permissions:** Implement logic based on user roles or data state (distinct from view permissions).
- **Transactions:** Use `@transaction.atomic` on methods needing atomicity (multi-model updates, critical state changes). Be mindful of nested atomicity/savepoints.
- **Error Handling:** Raise `django.core.exceptions.ValidationError` (with dict mapping fields/`NON_FIELD_ERRORS` to `ValidationError` lists) for business rule violations. Caller (View, Task) handles these.
- **Calling:** Called from Views, Tasks, other Services, management commands. Avoid calling from Forms/Models.

### Service Example (Conceptual Structure)

"""
# app/services/some_service.py
from django.db import transaction
from django.core.exceptions import ValidationError
# ... other imports

class SomeService:
    @classmethod
    @transaction.atomic
    def perform_complex_action(cls, user_id: int, data: dict) -> ModelInstance:
        # 1. Fetch necessary model instances (e.g., user = User.get_by_id(user_id))
        # 2. Check domain permissions / business rules
        #    if not cls._can_user_perform_action(user, data):
        #        raise ValidationError(...)
        # 3. Perform logic, potentially interacting with multiple models or interfaces
        #    instance = Model.objects.create(...)
        #    related_instance.status = 'updated'
        #    external_ref = some_interface.call_api(...)
        # 4. Persist changes
        #    instance.external_ref = external_ref
        #    instance.save()
        #    related_instance.save()
        # 5. Handle potential external call failures / inconsistencies if needed
        # 6. Return result or raise ValidationError on failure
        return instance

    @classmethod
    def _can_user_perform_action(cls, user, data) -> bool:
        # ... internal helper for permission/rule checks ...
        return True
"""

---

## Models (`models.py`)

- **Purpose:** Define DB schema, relationships, simple/reusable data access methods/properties.
- **Fields & Relationships:** Define fields (`CharField`, `ForeignKey`, etc.) and `related_name`.
- **Methods:**
    - **Query Helpers (Optional):** Simple, reusable classmethods for common lookups (e.g., `get_by_id`, `get_active_users`). No complex business logic filtering. Use `select_related`/`prefetch_related` appropriately.
    - **Properties:** `@property` for simple derived attributes (no complex logic/DB queries).
    - **`__str__`:** Human-readable representation.
- **NO Business Logic:** Agnostic to data usage. No complex state transitions, external calls, domain permissions.
- **NO Direct Persistence in Methods:** Avoid methods like `update_status_and_save()`. Services handle persistence.
- **Atomicity:** Usually handled by calling service. For specific read-modify-write needs (e.g., counters), use `select_for_update()` in the query (within the service's atomic block).
- **Managers/QuerySets:** Use custom Managers/QuerySets for reusable filtering (e.g., `Product.objects.available()`). Focus on filtering/querying, not business logic.

### Model Example (Conceptual Structure)

"""
# app/models/some_model.py
from django.db import models
# ... other imports

class SomeModelQuerySet(models.QuerySet):
    def active(self):
        return self.filter(is_active=True)
    # ... other reusable filters

class SomeModel(models.Model):
    name = models.CharField(...)
    status = models.CharField(...)
    # ... other fields and relationships

    objects = SomeModelQuerySet.as_manager()

    def __str__(self):
        return self.name

    @property
    def derived_info(self):
        # ... simple calculation based on fields ...
        return f"{self.name} ({self.status})"

    @classmethod
    def get_by_uuid(cls, uuid):
        # ... simple lookup helper ...
        try:
            return cls.objects.get(uuid=uuid)
        except cls.DoesNotExist:
            raise # Let caller handle

    # AVOID: def complex_business_action(self): ...
    # AVOID: def update_and_save(self, new_status): self.status = new_status; self.save()
"""

---

## Views (`views.py`)

- **Purpose:** Handle HTTP request/response, view-level auth/permissions, call services, manage forms, render responses (HTML/JSON).
- **Request/Response:** Process `request`, extract data, return `HttpResponse` (`render`, `redirect`, etc.).
- **Auth/Permissions:** Use Django auth (`LoginRequiredMixin`, `PermissionRequiredMixin`) for *view access*. Raise `Http404`, `PermissionDenied`.
- **Service Interaction:** Call service methods (e.g., `SomeService.perform_complex_action(...)`) for data/actions.
- **Form Handling:**
    - Instantiate forms (`MyForm(request.POST or None)`).
    - Check `form.is_valid()`.
    - If valid, pass `form.cleaned_data` to service.
    - If service raises `ValidationError`, catch and add errors to form (`form.add_error(...)`), then re-render invalid form.
    - If form invalid initially, render with errors.
- **Context Data:** Populate template context (`get_context_data`), usually with data from services.
- **Templating:** Render templates (`render`, `redirect`). Return HTML fragments for HTMX.

### View Example (Conceptual Structure - CBV)

"""
# app/views/some_views.py
from django.views.generic import FormView, DetailView
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.exceptions import ValidationError
# ... other imports
from app.forms import SomeForm
from app.services import SomeService
from app.models import SomeModel

class CreateSomethingView(LoginRequiredMixin, FormView):
    template_name = "app/create_something.html"
    form_class = SomeForm
    success_url = "..."

    def form_valid(self, form):
        try:
            result = SomeService.perform_complex_action(
                user_id=self.request.user.id,
                data=form.cleaned_data
            )
            # ... handle success (e.g., redirect) ...
            return redirect(self.get_success_url())
        except ValidationError as e:
            # ... add errors from service back to form ...
            for field, errors in e.message_dict.items():
                form.add_error(field if field != '__all__' else None, errors)
            return self.form_invalid(form)
        except Exception as e:
            # ... handle unexpected errors ...
            form.add_error(None, "Unexpected error.")
            return self.form_invalid(form)

class SomethingDetailView(LoginRequiredMixin, DetailView):
    model = SomeModel
    template_name = 'app/detail_something.html'

    def get_queryset(self):
        # ... filter based on view-level permissions (e.g., user ownership) ...
        return super().get_queryset().filter(owner=self.request.user)
"""

---

## Forms (`forms.py`)

- **Purpose:** Define and validate user input based on static rules, types, constraints. No DB access (except `ModelChoiceField` choices) or external calls.
- **Fields:** Define form fields (`CharField`, `IntegerField`, etc.).
- **Validation:**
    - Use built-in validators (`required`, `max_length`).
    - Implement `clean_<fieldname>()` for single-field validation.
    - Implement `clean()` for cross-field validation.
    - Raise `forms.ValidationError` on failure.
- **NO Database Queries:** (Except for populating choices like `ModelChoiceField`).
- **NO Business Logic Calls:** Do not call Services/Interfaces.

### Form Example (Conceptual Structure)

"""
# app/forms/some_forms.py
from django import forms

class SomeForm(forms.Form):
    name = forms.CharField(max_length=100, required=True)
    email = forms.EmailField(required=False)
    # ... other fields

    def clean_name(self):
        name = self.cleaned_data.get('name')
        # ... perform static validation on name (e.g., check for forbidden words) ...
        if "forbidden" in name.lower():
            raise forms.ValidationError("Name contains forbidden words.")
        return name

    def clean(self):
        cleaned_data = super().clean()
        # ... perform cross-field validation ...
        # if condition_based_on_multiple_fields:
        #     raise forms.ValidationError("Cross-field validation failed.")
        return cleaned_data
"""

---

## Interfaces (`interfaces/` package)

- **Purpose:** Abstract communication with external APIs/services.
- **Location:** `app/interfaces/`.
- **Implementation:** Wrap client libraries (`requests`, SDKs). Handle external auth, request formatting, response parsing.
- **NO Business Logic:** Translate calls/responses only.
- **Error Handling:** Catch external library exceptions, re-raise as custom exceptions or return standard errors.
- **Calling:** Called only by Services.

### Interface Example (Conceptual Structure)

"""
# app/interfaces/external_api.py
import requests
from django.conf import settings

class ExternalApiError(Exception): pass

class ExternalApiInterface:
    def __init__(self):
        # ... setup API key, base URL from settings ...
        pass

    def call_endpoint(self, param1: str) -> dict:
        # ... construct URL, payload, headers ...
        try:
            response = requests.post(...)
            response.raise_for_status()
            data = response.json()
            # ... check response status from API ...
            if data.get("status") == "success":
                return data.get("payload", {})
            else:
                raise ExternalApiError(f"API Error: {data.get('error')}")
        except requests.exceptions.RequestException as e:
            raise ExternalApiError(f"Communication error: {e}") from e
        except Exception as e:
            raise ExternalApiError(f"Unexpected error: {e}") from e

# external_api = ExternalApiInterface() # Optional instantiation
"""

---

## Tasks (`tasks.py`)

- **Purpose:** Define background tasks (e.g., Celery).
- **Location:** `app/tasks.py`.
- **Implementation:** Use `@shared_task` / `@app.task`.
- **Logic:** Primarily call Service methods. Avoid complex logic in the task itself.
- **Error Handling:** Catch exceptions (esp. `ValidationError` from services), log, handle retries (`self.retry`). Don't let unexpected exceptions propagate out.
- **Arguments:** Pass simple, serializable arguments (IDs, primitives), not model instances.

### Task Example (Conceptual Structure)

"""
# app/tasks.py
from celery import shared_task
import logging
from app.services import SomeService
# ... other imports

logger = logging.getLogger(__name__)

@shared_task(bind=True, max_retries=3)
def process_something_async(self, item_id: int, user_id: int):
    try:
        logger.info(f"Task started for item {item_id}")
        SomeService.process_item(item_id=item_id, triggered_by=user_id)
        logger.info(f"Task finished for item {item_id}")
    except ValidationError as e:
        logger.error(f"Task Validation Error for item {item_id}: {e}")
        # Non-retryable usually
    except Exception as e:
        logger.exception(f"Task Error for item {item_id}. Retrying...")
        try:
            raise self.retry(exc=e)
        except self.MaxRetriesExceededError:
            logger.error(f"Task Max Retries Exceeded for item {item_id}.")
"""

---

## URLs (`urls.py`)

- **Purpose:** Map URL patterns to Views.
- **Structure:** Use `include()` for app URLs. Define `app_name` for namespacing.
- **Patterns:** Use `path()`. Name patterns (`name='...'`) for `reverse_lazy`/`{% url %}`.

### URL Example (Conceptual Structure)

"""
# project/urls.py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('app/', include('app.urls', namespace='app')),
    # ...
]

# app/urls.py
app_name = 'app'
urlpatterns = [
    path('create/', views.CreateSomethingView.as_view(), name='create'),
    path('<int:pk>/', views.SomethingDetailView.as_view(), name='detail'),
    # ...
]
"""

---

## Atomicity & Race Conditions

- **Primary Control:** Use `@transaction.atomic` on **Service methods** for writes/related changes.
- **Read-Modify-Write:** Use `select_for_update()` in queries *within* the atomic service method to lock rows for race-condition-sensitive operations (e.g., decrementing stock).
- **Nested Transactions:** Inner atomic blocks usually create savepoints (default). Errors roll back to savepoint or entire transaction if outermost. `savepoint=False` affects error handling (use cautiously).
- **External Calls:** Avoid within atomic blocks if possible. If necessary, handle potential inconsistencies (external call succeeds, transaction rolls back).

---

## Validators vs. Checkers

- **Checkers:** Simple boolean methods (often on Models) checking state without raising errors (e.g., `order.is_shipped() -> bool`).
- **Validators:** Logic (in Services/Forms) using checkers/conditions, raising `ValidationError` if rules fail. Forms = input validation; Services = business rule validation.

---

## Business Logic Definition

- Resides in **Services**.
- Includes domain-specific rules, state dependencies, role-based logic, workflows.
- **Example:** Service validates "Free users limited to 5 projects"; Form validates "Project name max 100 chars".
- If a rule must *always* apply (regardless of entry point: View, Task, API), it *must* be in the Service.

=================================
# Frontend Conventions

- **Templating Engine:** Standard Django Template Language (DTL).
- **Structure:**
    - Project `templates/base.html`.
    - App `templates/<app_name>/` directories, extending `base.html`.
    - Use `{% include %}` extensively for reusable components (e.g., `templates/includes/nav.html`, `app/templates/app/includes/card.html`). Organize includes logically.
- **Styling:** **Tailwind CSS v3**.
    - Configure and compile via standard Tailwind tooling.
    - Link single compiled CSS in `base.html`.
    - Use utility classes directly in templates. Avoid inline `style="..."`.
- **Interactivity:** **HTMX** primary mechanism for dynamic updates/partial loads.
    - Views return HTML fragments for HTMX swapping.
    - Use `hx-*` attributes in templates.
- **JavaScript:** Minimize custom JS. Use only when HTMX/HTML/CSS insufficient.
    - Place in static files (e.g., `static/js/app.js`), bundle/import in `base.html`.
    - Consider Alpine.js for small, isolated behaviors if needed, but prefer HTMX.
- **Asset Management:** Use Django `staticfiles` (`{% static %}`).
- **Composability:** Design Views/Templates for seamless integration (Views provide context, Templates render using DTL/HTMX/includes). Aim for monolithic feel.
- **Code Quality:** Modern, clean practices. Current library versions (Django, Tailwind, HTMX). Readable, structured templates.
=================================
